"use strict";(self.webpackChunksupastash_docs=self.webpackChunksupastash_docs||[]).push([[222],{17:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"sync-calls","title":"sync-calls","description":"\u2699\ufe0f Registering Custom Sync Calls (syncCalls)","source":"@site/docs/sync-calls.md","sourceDirName":".","slug":"/sync-calls","permalink":"/supastash/docs/sync-calls","draft":false,"unlisted":false,"editUrl":"https://github.com/0xZekeA/supastash/tree/main/docs-site/docs/sync-calls.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Sync Flows","permalink":"/supastash/docs/sync-flows"},"next":{"title":"Runtime Modes (New)","permalink":"/supastash/docs/supastash-runtime-modes"}}');var t=s(4848),l=s(8453);const a={},i=void 0,c={},o=[{value:"\u2699\ufe0f Registering Custom Sync Calls (<code>syncCalls</code>)",id:"\ufe0f-registering-custom-sync-calls-synccalls",level:2},{value:"\ud83e\udde9 API",id:"-api",level:3},{value:"<code>registerSyncCall(table: string, entry: SyncEntry, options?: { allowOverride?: boolean })</code>",id:"registersynccalltable-string-entry-syncentry-options--allowoverride-boolean-",level:4},{value:"<code>unregisterSyncCall(table: string)</code>",id:"unregistersynccalltable-string",level:4},{value:"<code>getSyncCall(table: string)</code>",id:"getsynccalltable-string",level:4},{value:"<code>getAllSyncTables()</code>",id:"getallsynctables",level:4},{value:"<code>clearSyncCalls()</code>",id:"clearsynccalls",level:4},{value:"\ud83d\ude80 Example 1: Using a Custom RPC for Push",id:"-example-1-using-a-custom-rpc-for-push",level:3},{value:"\ud83d\udcac Example 2: Pull + Mark Messages as Delivered",id:"-example-2-pull--mark-messages-as-delivered",level:3},{value:"\ud83e\udde0 Notes",id:"-notes",level:3},{value:"\ud83d\udd27 <code>pushRPCPath</code> (Custom Batch Sync RPC)",id:"-pushrpcpath-custom-batch-sync-rpc",level:2},{value:"Why Use a Custom RPC?",id:"why-use-a-custom-rpc",level:3},{value:"Example: Configuring in Supastash",id:"example-configuring-in-supastash",level:3},{value:"Reference RPC: <code>supastash_batch_sync</code>",id:"reference-rpc-supastash_batch_sync",level:3},{value:"Expected Return Shape",id:"expected-return-shape",level:3},{value:"\ud83e\udde0 Summary",id:"-summary",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h2,{id:"\ufe0f-registering-custom-sync-calls-synccalls",children:["\u2699\ufe0f Registering Custom Sync Calls (",(0,t.jsx)(n.code,{children:"syncCalls"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["Supastash lets you override or extend how specific tables ",(0,t.jsx)(n.strong,{children:"push"})," or ",(0,t.jsx)(n.strong,{children:"pull"})," data during synchronization \u2014 without modifying the core sync engine."]}),"\n",(0,t.jsx)(n.p,{children:"This is ideal when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You want to run a ",(0,t.jsx)(n.strong,{children:"custom RPC"})," instead of the standard ",(0,t.jsx)(n.code,{children:"upsert()"})," logic."]}),"\n",(0,t.jsxs)(n.li,{children:["You want to perform a ",(0,t.jsx)(n.strong,{children:"custom pull"})," (e.g., fetching messages and marking them as delivered)."]}),"\n",(0,t.jsxs)(n.li,{children:["You want ",(0,t.jsx)(n.strong,{children:"per-table sync behavior"})," (e.g., special logic for ",(0,t.jsx)(n.code,{children:"sales"})," or ",(0,t.jsx)(n.code,{children:"messages"}),")."]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"Note:"})," Using custom sync calls will ",(0,t.jsx)(n.strong,{children:"bypass Supastash\u2019s internal consistency and conflict handling"}),". This may compromise how Supastash manages synced data. Only use this feature if you fully understand your sync logic and its implications."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"You can skip directly to the detailed RPC setup section below:"}),"\n",(0,t.jsxs)(n.p,{children:["\u27a1\ufe0f ",(0,t.jsxs)(n.a,{href:"#-pushrpcpath-custom-batch-sync-rpc",children:["Go to ",(0,t.jsx)(n.code,{children:"pushRPCPath"})," (Custom Batch Sync RPC)"]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-api",children:"\ud83e\udde9 API"}),"\n",(0,t.jsx)(n.h4,{id:"registersynccalltable-string-entry-syncentry-options--allowoverride-boolean-",children:(0,t.jsx)(n.code,{children:"registerSyncCall(table: string, entry: SyncEntry, options?: { allowOverride?: boolean })"})}),"\n",(0,t.jsx)(n.p,{children:"Registers a custom sync handler for a given table."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"table"})," \u2013 The name of the table to attach the sync logic to."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"entry"})," \u2013 The sync configuration object:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"type PushFn = (payload: any) => Promise<boolean>;\ntype PullFn = (payload: any) => Promise<void>;\n\ntype SyncEntry = {\n  push?: PushFn; // Must return true if successful, false otherwise\n  pull?: PullFn; // Handles remote \u2192 local updates or side effects\n};\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"allowOverride"})," \u2013 Whether to replace an existing registration (default: ",(0,t.jsx)(n.code,{children:"false"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h4,{id:"unregistersynccalltable-string",children:(0,t.jsx)(n.code,{children:"unregisterSyncCall(table: string)"})}),"\n",(0,t.jsx)(n.p,{children:"Removes a sync call registration for the specified table."}),"\n",(0,t.jsx)(n.h4,{id:"getsynccalltable-string",children:(0,t.jsx)(n.code,{children:"getSyncCall(table: string)"})}),"\n",(0,t.jsx)(n.p,{children:"Retrieves the sync entry registered for the specified table."}),"\n",(0,t.jsx)(n.h4,{id:"getallsynctables",children:(0,t.jsx)(n.code,{children:"getAllSyncTables()"})}),"\n",(0,t.jsx)(n.p,{children:"Returns a list of all registered table names."}),"\n",(0,t.jsx)(n.h4,{id:"clearsynccalls",children:(0,t.jsx)(n.code,{children:"clearSyncCalls()"})}),"\n",(0,t.jsx)(n.p,{children:"Clears all custom sync call registrations."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-example-1-using-a-custom-rpc-for-push",children:"\ud83d\ude80 Example 1: Using a Custom RPC for Push"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { registerSyncCall } from "supastash/core/sync/registerSyncCall";\nimport { supabase } from "@/lib/supabase";\n\nregisterSyncCall("sales", {\n  async push(rows) {\n    const { error } = await supabase.rpc("batch_sync", {\n      target_table: "sales",\n      payload: rows,\n      columns: Object.keys(rows[0] ?? {}),\n    });\n\n    if (error) {\n      console.error("[Supastash] RPC push failed:", error);\n      // Your retry logic\n      // ...\n      if (failed) return false; // failed, will retry later\n    }\n\n    return true; // success, mark rows as synced\n  },\n});\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-example-2-pull--mark-messages-as-delivered",children:"\ud83d\udcac Example 2: Pull + Mark Messages as Delivered"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'registerSyncCall("messages", {\n  async pull(payload) {\n    // Your logic\n    // ..\n    // Add payload to local db\n    const { data, error } = await supastash\n      .from("messages")\n      .upsert(payload)\n      .syncMode("localOnly")\n      .run();\n\n    if (error) throw error;\n\n    // Example: mark received messages as delivered\n    const deliveredIds = data.map((m) => m.id);\n    await supabase.rpc("mark_messages_delivered", { ids: deliveredIds });\n\n    console.log(`Pulled ${data.length} new messages`);\n  },\n});\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-notes",children:"\ud83e\udde0 Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"push()"})," must ",(0,t.jsx)(n.strong,{children:"always return a boolean"}),": ",(0,t.jsx)(n.code,{children:"true"})," for success, ",(0,t.jsx)(n.code,{children:"false"})," for failure."]}),"\n",(0,t.jsxs)(n.li,{children:["You can combine both ",(0,t.jsx)(n.code,{children:"push"})," and ",(0,t.jsx)(n.code,{children:"pull"})," for a single table."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"allowOverride"})," is ",(0,t.jsx)(n.code,{children:"false"}),", calling ",(0,t.jsx)(n.code,{children:"registerSyncCall()"})," again for the same table will be ignored."]}),"\n",(0,t.jsx)(n.li,{children:"Custom handlers integrate seamlessly with the existing Supastash scheduler."}),"\n",(0,t.jsxs)(n.li,{children:["\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"Warning:"})," Custom sync handlers ",(0,t.jsx)(n.strong,{children:"bypass Supastash\u2019s conflict resolution and validation layers"}),". You\u2019re responsible for ensuring integrity, timestamps, and conflict safety in your custom implementation."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"-pushrpcpath-custom-batch-sync-rpc",children:["\ud83d\udd27 ",(0,t.jsx)(n.code,{children:"pushRPCPath"})," (Custom Batch Sync RPC)"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"pushRPCPath"})," option in Supastash lets you replace the default ",(0,t.jsx)(n.code,{children:".upsert()"}),"-based push behavior with a ",(0,t.jsx)(n.strong,{children:"single RPC call"})," per batch. This is ideal for large datasets, or when your ",(0,t.jsx)(n.strong,{children:"RLS policies"})," treat inserts and updates differently."]}),"\n",(0,t.jsx)(n.h3,{id:"why-use-a-custom-rpc",children:"Why Use a Custom RPC?"}),"\n",(0,t.jsxs)(n.p,{children:["By default, Supastash syncs unsynced rows using ",(0,t.jsx)(n.code,{children:"upsert()"}),". While convenient, this has a limitation:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Supabase\u2019s ",(0,t.jsx)(n.code,{children:"upsert()"})," performs an ",(0,t.jsx)(n.strong,{children:"INSERT first"}),", even when the row already exists."]}),"\n",(0,t.jsxs)(n.li,{children:["If your RLS policies allow only ",(0,t.jsx)(n.code,{children:"UPDATE"})," (and not ",(0,t.jsx)(n.code,{children:"INSERT"}),"), the call will fail entirely \u2014 and vice versa."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"A custom RPC solves this by separating updates and inserts server-side, allowing your RLS to stay precise and efficient."}),"\n",(0,t.jsx)(n.p,{children:"This also offers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance gains"}),": one batch RPC per chunk instead of hundreds of ",(0,t.jsx)(n.code,{children:".upsert()"})," calls."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Custom conflict handling"}),": define how your RPC treats stale or unauthorized rows."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Egress reduction"}),": freshness checks and filtering are done inside Postgres."]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"Important:"})," Your RPC must handle ",(0,t.jsx)(n.code,{children:"updated_at"})," freshness verification (only update when the incoming record is newer) and must return a structured result so Supastash can reconcile local sync states."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"example-configuring-in-supastash",children:"Example: Configuring in Supastash"}),"\n",(0,t.jsx)(n.p,{children:"Once you\u2019ve created your RPC (see next section for reference), add it to your Supastash configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { configureSupastash } from "supastash";\nimport { supabase } from "@/lib/supabase";\n\nconfigureSupastash({\n  dbName: "supastash_db",\n  supabaseClient: supabase,\n  // ... other options\n\n  // \ud83d\udc47 Add your RPC name here\n  pushRPCPath: "supastash_batch_sync",\n});\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Supastash will now call your RPC automatically for all push operations, passing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'await supabase.rpc("supastash_batch_sync", {\n  target_table: table,\n  payload: rows,\n  columns: Object.keys(rows[0] ?? {}),\n});\n'})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"reference-rpc-supastash_batch_sync",children:["Reference RPC: ",(0,t.jsx)(n.code,{children:"supastash_batch_sync"})]}),"\n",(0,t.jsxs)(n.p,{children:["A generic, table-agnostic RPC. It stages JSON into the table\u2019s row type (no manual casts), updates only when newer, inserts when missing, and returns per-row results including ",(0,t.jsx)(n.code,{children:"record_exists"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"\ndrop function supastash_batch_sync;\ncreate or replace function public.supastash_batch_sync(\n  target_table text,\n  payload jsonb,\n  columns text[]\n)\nreturns table (\n  id uuid,\n  action text,\n  reason text,\n  record_exists boolean\n)\nlanguage plpgsql\nsecurity invoker\nas $$\ndeclare\n  collist text;\n  update_assign text;\n  insert_cols text;\n  insert_vals text;\n  dyn_sql text;\n  qual text;\nbegin\n  -- 1 Prepare column lists\n  collist := array_to_string(columns, ', ');\n  update_assign := array_to_string(\n    array(\n      select format('%I = i.%I', c, c)\n      from unnest(columns) as c\n      where c not in ('id')\n    ), ', '\n  );\n  insert_cols := collist;\n  insert_vals := array_to_string(\n    array(\n      select format('i.%I', c)\n      from unnest(columns) as c\n    ), ', '\n  );\n\n  -- 2 Stage incoming data\n  -- build fully qualified table type\n  qual := format('public.%I', target_table);\n  EXECUTE format(\n    'create temp table _incoming on commit drop as\n    select * from jsonb_populate_recordset(NULL::%s, $1)',\n    qual\n  ) USING payload;\n\n\n\n  -- 3 Results collector\n  create temp table _results (\n    id uuid,\n    action text,\n    reason text,\n    record_exists boolean\n  ) on commit drop;\n\n  -- 4 Update existing newer rows\n  EXECUTE format(\n    'with upd as (\n       update %I t\n          set %s\n         from _incoming i\n        where t.id = i.id\n          and i.updated_at > t.updated_at\n        returning t.id\n      )\n    insert into _results\n    select id, ''updated'', null, true from upd;',\n    target_table,\n    array_to_string(\n      ARRAY(\n        SELECT CASE WHEN c = 'id' THEN NULL ELSE format('%I = i.%I', c, c) END\n        FROM unnest(columns) AS c\n        WHERE c <> 'id'\n      ),\n      ', '\n    )\n  );\n\n  -- 5 Insert new rows if not present\n  EXECUTE format(\n    'with ins as (\n      insert into %I (%s)\n      select %s from _incoming i\n      where not exists (select 1 from %I t where t.id = i.id)\n      on conflict (id) do nothing\n      returning id\n    )\n    insert into _results\n    select id, ''inserted'', null, false from ins;',\n    target_table,\n    array_to_string(columns, ', '),\n    array_to_string(ARRAY(SELECT format('i.%I', c) FROM unnest(columns) AS c), ', '),\n    target_table\n  );\n\n  -- 6 Mark stale rows (remote newer)\n  dyn_sql := format(\n    'insert into _results\n       select i.id::uuid, ''skipped'', ''stale_remote'', true\n       from _incoming i\n       join %I t on t.id = i.id::uuid\n       where i.updated_at::timestamptz <= t.updated_at\n       and not exists (\n    select 1 from _results r where r.id = i.id::uuid\n  );',\n    target_table\n  );\n  execute dyn_sql;\n\n  -- 7 Catch any remaining missing/conflicted\n  dyn_sql := format(\n    'insert into _results\n      select i.id::uuid, ''skipped'', ''conflict_or_unauthorized'',\n      (t.id is not null) as exists\n      from _incoming i\n      left join %I t on t.id = i.id::uuid\n     where not exists (\n    select 1 from _results r where r.id = i.id::uuid\n  );',\n  target_table\n  );\n  execute dyn_sql;\n\n  -- 8 Return unified results\n  return query select * from _results;\nend;\n$$;\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"expected-return-shape",children:"Expected Return Shape"}),"\n",(0,t.jsx)(n.p,{children:"Your RPC must return an array of objects like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'{\n  id: string; // UUID of the row\n  action: "updated" | "inserted" | "skipped";\n  reason: "stale_remote", "conflict_or_unauthorized" | null; // if skipped, specify a reason, \'stale_remote\' when remote row is newer\n  record_exists: boolean; // Whether the row already exists remotely\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Supastash uses this data to decide whether to retry, skip, or reinsert specific rows during sync."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-summary",children:"\ud83e\udde0 Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Use **"}),"pushRPCPath** when RLS policies differ for ",(0,t.jsx)(n.code,{children:"INSERT"})," vs ",(0,t.jsx)(n.code,{children:"UPDATE"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["\ud83e\udde9 ",(0,t.jsx)(n.strong,{children:"RPC executes server-side"}),", reducing client-side logic and network usage."]}),"\n",(0,t.jsxs)(n.li,{children:["\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"Always include freshness checks"})," (",(0,t.jsx)(n.code,{children:"local.updated_at > remote.updated_at"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["\ud83e\uddf1 ",(0,t.jsx)(n.strong,{children:"Leave room for conflict reasons"})," (",(0,t.jsx)(n.code,{children:"stale_remote"}),", ",(0,t.jsx)(n.code,{children:"conflict_or_unauthorized"}),", etc.) for better visibility."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var r=s(6540);const t={},l=r.createContext(t);function a(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);