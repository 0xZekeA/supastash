"use strict";(self.webpackChunksupastash_docs=self.webpackChunksupastash_docs||[]).push([[1254],{6325:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"sync-flows","title":"Sync","description":"---","source":"@site/docs/sync-flows.md","sourceDirName":".","slug":"/sync-flows","permalink":"/supastash/docs/sync-flows","draft":false,"unlisted":false,"editUrl":"https://github.com/0xZekeA/supastash/tree/main/docs-site/docs/sync-flows.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Configuration","permalink":"/supastash/docs/configuration"}}');var r=n(4848),a=n(8453);const i={},l="Sync",c={},o=[{value:"\ud83d\udd04 <code>syncTable(table: string): Promise&lt;void&gt;</code>",id:"-synctabletable-string-promisevoid",level:2},{value:"\u26a0\ufe0f No Duplicate Syncs",id:"\ufe0f-no-duplicate-syncs",level:3},{value:"\u2705 Real-World Example: Pull-to-Refresh with FlatList",id:"-real-world-example-pull-to-refresh-with-flatlist",level:3},{value:"\ud83e\udde0 Pro Tips",id:"-pro-tips",level:3},{value:"\ud83d\udd04 <code>syncAllTables(): Promise&lt;void&gt;</code>",id:"-syncalltables-promisevoid",level:2},{value:"Example: Sync on App Resume",id:"example-sync-on-app-resume",level:3}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"sync",children:"Sync"})}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.h2,{id:"-synctabletable-string-promisevoid",children:["\ud83d\udd04 ",(0,r.jsx)(s.code,{children:"syncTable(table: string): Promise<void>"})]}),"\n",(0,r.jsxs)(s.p,{children:["Triggers a manual sync for a ",(0,r.jsx)(s.strong,{children:"single table"})," between your local SQLite database and Supabase."]}),"\n",(0,r.jsxs)(s.p,{children:["Use this when you need to ",(0,r.jsx)(s.strong,{children:"manually refresh data"}),"\u2014like when a user pulls to refresh a list, or when you want instant consistency after a local update."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"\ufe0f-no-duplicate-syncs",children:"\u26a0\ufe0f No Duplicate Syncs"}),"\n",(0,r.jsxs)(s.p,{children:["If a sync is already in progress for the specified table, ",(0,r.jsx)(s.code,{children:"syncTable"})," will quietly skip it.\nThis prevents redundant work and avoids potential race conditions behind the scenes."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"-real-world-example-pull-to-refresh-with-flatlist",children:"\u2705 Real-World Example: Pull-to-Refresh with FlatList"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-tsx",children:'import React, { useCallback, useState } from "react";\nimport { FlatList, RefreshControl, Text, View } from "react-native";\nimport { useSupastashData, syncTable } from "supastash";\n\nconst OrdersScreen = () => {\n  const { data: orders } = useSupastashData("orders");\n  const [isRefreshing, setIsRefreshing] = useState(false);\n\n  const refresh = useCallback(async () => {\n    if (isRefreshing) return;\n    setIsRefreshing(true);\n    try {\n      await syncTable("orders");\n    } finally {\n      setIsRefreshing(false);\n    }\n  }, [isRefreshing]);\n\n  return (\n    <FlatList\n      data={orders}\n      keyExtractor={(item) => item.id}\n      renderItem={({ item }) => (\n        <View style={{ padding: 16 }}>\n          <Text>{item.title}</Text>\n        </View>\n      )}\n      refreshing={isRefreshing}\n      onRefresh={refresh}\n    />\n  );\n};\n'})}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"-pro-tips",children:"\ud83e\udde0 Pro Tips"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Use this pattern anywhere the user might expect a manual refresh."}),"\n",(0,r.jsxs)(s.li,{children:["Guard with ",(0,r.jsx)(s.code,{children:"isRefreshing"})," to keep your UI snappy and avoid stacked requests."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"syncTable"})," already skips syncing if one is active, but combining both guards (internal and UI-level) is the safest bet."]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.h2,{id:"-syncalltables-promisevoid",children:["\ud83d\udd04 ",(0,r.jsx)(s.code,{children:"syncAllTables(): Promise<void>"})]}),"\n",(0,r.jsxs)(s.p,{children:["Triggers a manual sync for ",(0,r.jsx)(s.strong,{children:"all Supastash tables"}),"\u2014regardless of polling cycles."]}),"\n",(0,r.jsx)(s.p,{children:"Great for situations like:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"App resume (sync everything fresh)"}),"\n",(0,r.jsx)(s.li,{children:"Manual \u201cSync Now\u201d buttons"}),"\n",(0,r.jsx)(s.li,{children:"Recovery after a failed background sync"}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"example-sync-on-app-resume",children:"Example: Sync on App Resume"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:'import { syncAllTables } from "supastash";\nimport { AppState } from "react-native";\n\nuseEffect(() => {\n  const sub = AppState.addEventListener("change", async (state) => {\n    if (state === "active") {\n      await syncAllTables(); // sync everything when app becomes active\n    }\n  });\n\n  return () => sub.remove();\n}, []);\n'})}),"\n",(0,r.jsxs)(s.p,{children:["\u2192 See also: ",(0,r.jsx)(s.a,{href:"/supastash/docs/useSupastashData",children:(0,r.jsx)(s.code,{children:"useSupastashData"})})]})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>l});var t=n(6540);const r={},a=t.createContext(r);function i(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);